# Template for db_inputs.conf file for DB Connect App, to collect data for 3CX App

###########################################################################
## <provide host-name for 3CX> -> Replace with 3CX host name
##
## Also update the date and time for tail_rising_column_init_ckpt_value parameter in all the inputs based on how long in the past you want to backfill the data.
##  * Please use `YY-mm-dd HH:MM:SS.000` date-time format.
##  * Example: `tail_rising_column_init_ckpt_value = {"value":"2021-09-21 00:00:00.000","columnType":93}`
##  * Please do not go long in the past as all queries will timed-out and you will never be able to collect the data.
###########################################################################


[default]
host = <provide host-name for 3CX>


[3cx_calls]
connection = 3CX
disabled = 0
index = 3cxtest
index_time_mode = dbColumn
input_timestamp_column_number = 9
# input_timestamp_column_name = seg_start_time
interval = */15 * * * *
mode = rising
tail_rising_column_name = seg_end_time
tail_rising_column_init_ckpt_value = {"value":"YY-mm-dd HH:MM:SS.000","columnType":93}
query = SELECT calls.id AS call_id, calls.start_time as call_start_time, calls.end_time as call_end_time, calls.is_answered as call_is_answered, calls.ringing_dur as call_ringing_dur, calls.talking_dur as call_talking_dur, calls.q_wait_dur as call_q_wait_dur, \
segments.id as seg_id, segments.start_time as seg_start_time, segments.end_time as seg_end_time, segments.seq_group as seg_group, segments.seq_order as seg_order, segments.type as seg_type, segments.action_id as seg_action_id, segments.action_party_id as seg_action_party_id, \
src_participants.role as src_role, src_participants.is_inbound as src_is_inbound, src_participants.end_status as src_end_status, src_participants.forward_reason as src_forward_reason, src_participants.failure_reason as src_failure_reason, src_participants.answer_time as answer_time, src_participants.recording_url as src_recording_url, \
src_info.dn_type as src_type, src_info.dn as src_dn, src_info.caller_number as src_caller_number, src_info.display_name as src_display_name, \
dst_participants.role as dst_role, dst_participants.is_inbound as dst_is_inbound, dst_participants.end_status as dst_end_status, dst_participants.forward_reason as dst_forward_reason, dst_participants.failure_reason as dst_failure_reason, dst_participants.recording_url as dst_recording_url, \
dst_info.dn_type as dst_type, dst_info.dn as dst_dn, dst_info.caller_number as dst_caller_number, dst_info.display_name as dst_display_name, \
act_participants.role as act_role, act_participants.is_inbound as act_is_inbound, act_participants.end_status as act_end_status, act_participants.forward_reason as act_forward_reason, act_participants.failure_reason as act_failure_reason, \
act_info.dn_type as act_type, act_info.dn as act_dn, act_info.caller_number as act_caller_number, act_info.display_name as act_display_name \
FROM cl_calls as calls JOIN cl_segments as segments ON calls.id = segments.call_id AND segments.end_time>=? \
JOIN cl_participants as src_participants ON segments.src_part_id = src_participants.id \
JOIN cl_participants as dst_participants ON segments.dst_part_id = dst_participants.id \
JOIN cl_party_info as src_info ON src_participants.info_id = src_info.id \
JOIN cl_party_info as dst_info ON dst_participants.info_id = dst_info.id  \
LEFT OUTER JOIN cl_participants as act_participants ON segments.action_party_id = act_participants.id \
LEFT OUTER JOIN cl_party_info as act_info ON act_participants.info_id = act_info.id \
ORDER BY seg_end_time ASC
sourcetype = 3cx:calls



[agent_login_export]
connection = 3CX
disabled = 0
index = 3cx
index_time_mode = dbColumn
input_timestamp_column_number = 5
interval = 0,30 * * * *
mode = batch
query = WITH\
    rows\
    AS\
    (\
        SELECT idcallcent_ag_queuestatus, q_num, ag_num, users.firstname, users.lastname AS ag_lname, timeofupdate, is_loggedin_in_queue, is_loggedin_in_allqueues, ROW_NUMBER() OVER  (ORDER BY q_num, ag_num, timeofupdate) AS rn, LAG(timeofupdate) OVER  (ORDER BY q_num, ag_num, timeofupdate) pDataDate\
        FROM callcent_ag_queuestatus INNER JOIN dn on (cast (dn.value as int8) = cast(callcent_ag_queuestatus.ag_num as int8)) INNER JOIN extension ON (dn.iddn = cast (extension.fkiddn as int8)) INNER JOIN users ON (extension.fkiddn = users.fkidextension)\
    ),\
    rowsIn\
    AS\
    (\
        SELECT idcallcent_ag_queuestatus, q_num, ag_num, timeofupdate, is_loggedin_in_queue, is_loggedin_in_allqueues, rn, pDataDate\
        FROM rows INNER JOIN dn on (cast (dn.value as int8) = cast(rows.ag_num as int8)) INNER JOIN extension ON (dn.iddn = cast (extension.fkiddn as int8)) INNER JOIN users ON (extension.fkiddn = users.fkidextension)\
        WHERE is_loggedin_in_queue='t'\
    ),\
    rowsOut\
    AS\
    (\
        SELECT idcallcent_ag_queuestatus, q_num, users.firstname, users.lastname, ag_num, timeofupdate, is_loggedin_in_queue, is_loggedin_in_allqueues, rn, pDataDate, CASE WHEN (LAG(rn) OVER (ORDER BY rn) + 1) IS NULL THEN 1 ELSE (LAG(rn) OVER (ORDER BY rn) + 1)   END as in_row\
        FROM rows INNER JOIN dn on (cast (dn.value as int8) = cast(rows.ag_num as int8)) INNER JOIN extension ON (dn.iddn = cast (extension.fkiddn as int8)) INNER JOIN users ON (extension.fkiddn = users.fkidextension)\
        WHERE is_loggedin_in_queue='f'\
    )\
SELECT o.q_num, o.ag_num, o.firstname AS ag_fname, o.lastname AS ag_lname, i.timeofupdate AT TIME ZONE 'UTC' as LoginTime, o.timeofupdate AT TIME ZONE 'UTC' as LogoutTime, ((DATE_PART('day', o.timeofupdate::timestamp - i.timeofupdate::timestamp) * 24 +  DATE_PART('hour', o.timeofupdate::timestamp - i.timeofupdate::timestamp)) * 60 +    DATE_PART('minute', o.timeofupdate::timestamp - i.timeofupdate::timestamp)) * 60 +    DATE_PART('second', o.timeofupdate::timestamp - i.timeofupdate::timestamp) as    SecondsLoggedIn\
FROM rowsOut o JOIN rowsIn i ON i.rn = o.in_row AND i.ag_num = o.ag_num AND o.q_num = i.q_num WHERE i.timeofupdate AT TIME ZONE 'UTC' > now() - interval '30 minutes'
sourcetype = 3cx:agent_logins

[queuecalls_view]
connection = 3CX
disabled = 0
index = 3cx
index_time_mode = dbColumn
input_timestamp_column_number = 5
interval = 0,30 * * * *
mode = batch
query = SELECT idcallcent_queuecalls,q.name AS q_name, q_num, dn.value, time_start AT TIME ZONE 'UTC' AS time_start, time_end AT TIME ZONE 'UTC' AS time_end, ts_waiting, ts_polling, ts_servicing, ts_locating, count_polls, count_dialed, count_rejected, count_dials_timed, reason_noanswercode, reason_noanswerdesc, reason_failcode, reason_faildesc, call_history_id, q_cal, from_userpart, from_displayname, to_dialednum, to_dn, urs.firstname AS ag_fname, urs.lastname AS ag_lname, to_dntype, cb_num, call_result, deal_status, is_visible, date_part('second', ts_waiting) + date_part('minute',ts_waiting)*60 + date_part('hour', ts_waiting)*3600 AS tot_waiting_sec,date_part('second', ts_polling) + date_part('minute',ts_polling)*60 + date_part('hour', ts_polling)*3600 AS tot_polling_sec,date_part('second', ts_servicing) + date_part('minute',ts_servicing)*60 + date_part('hour', ts_servicing)*3600 AS tot_servicing_sec,date_part('second', ts_locating) + date_part('minute',ts_locating)*60 + date_part('hour', ts_locating)*3600 AS tot_locating_sec,date_part('second', ts_waiting) + date_part('minute',ts_waiting)*60 + date_part('hour', ts_waiting)*3600 + date_part('second', ts_polling) + date_part('minute',ts_polling)*60 + date_part('hour', ts_polling)*3600 AS tot_ringing_sec,date_part('second', ts_polling) + date_part('minute',ts_polling)*60 + date_part('hour', ts_polling)*3600 - 20*(count_dialed - count_polls) AS tot_agent_polling_sec,CASE WHEN ts_servicing = '00:00:00.0000000' THEN 'Unserviced' ELSE 'Serviced' END AS serviced,CASE WHEN ts_servicing = '00:00:00.0000000' THEN 0 ELSE 1 END AS isserviced,                                                                                                    ((DATE_PART('day', time_end::timestamp - time_start::timestamp) * 24 + DATE_PART('hour', time_end::timestamp - time_start::timestamp)) * 60 + DATE_PART('minute', time_end::timestamp - time_start::timestamp)) * 60 + DATE_PART('second', time_end::timestamp - time_start::timestamp) AS duration                                                  FROM callcent_queuecalls INNER JOIN dn ON (q_num = dn.value) INNER JOIN ( SELECT queue.name, 'queue', queue.fkiddn FROM queue UNION ALL SELECT ringgroup.name, 'RG', ringgroup.fkiddn FROM ringgroup UNION ALL SELECT ivr.name, 'ivr', ivr.fkiddn FROM ivr ) q ON q.fkiddn = dn.iddn LEFT OUTER JOIN (SELECT dn.iddn, dn.value FROM dn ) directoryNum ON callcent_queuecalls.to_dn = directoryNum.value LEFT OUTER JOIN (Select extension.fkiddn, extension.authid FROM extension )ext ON directoryNum.iddn = ext.fkiddn LEFT OUTER JOIN (Select users.fkidextension, users.firstname, users.lastname FROM users ) urs ON urs.fkidextension = ext.fkiddn WHERE time_start AT TIME ZONE 'UTC' > now() - interval '30 minutes'
sourcetype = 3cx:queuecalls_view
